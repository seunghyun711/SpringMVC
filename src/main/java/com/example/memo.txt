<Jakarta Bean Validation>
-> dto클래스에의 유효성 검사를 위해 사용했던 애너테이션(@Valid)은 Jakarta Bean Validation이라는 유효성 검증을 위한 표준 스팩에서 지원하는 내장 애너테이션들이다.
Jakarta Bean Validation스펙을 구현한 구현체는 Hibernate Validator다.
Java Bean스펙을 준수하는 Java클래스는 Jakarta Bean Validation의 애너테이션을 사용하여 유효성 검증을 할 수 있다.

-> 만약 Jakarta Bean Validation의 애너테이션 중 목적에 맞는 애너테이션이 없을 수 있다.
이 떄 Custom Validator를 사용하여 목적에 맞는 애너테이션을 직접 만들어 적용할 수 있다.

-> Custom Validator 구현 절차
1. Custom Validator를 사용하기 위한 Custom 애너테이션 적용
2. 정의한 Custom 애너테이션에 바인딩 되는 Custom Validator를 구현한다.
3. 유효성 검증이 필요한 dto클래스의 멤버 변수에 Custom 애너테이션을 추가한다.

<서비스 계층과 API계층 연동(DI 적용O) - 까지의 문제점>
1. Controller 클래스에 있는 핸들러 메서드의 역할
- 핸들러 메서드 역할은 클라이언트로부터 전달 받은 요청 데이터를 Service 클래스로 전달하고, 응답 데이터를 클라이언트로 전달하는 역할이다.
그런데 현재 MemberContrller는 핸들러 메서드가 DTO 클래스를 Entity 객체로 변환하는 역할까지 맡고 있다.

2. Service계층에서 사용되는 Entity 객체를 클라이언트의 응답으로 전송한다.
- dto 클래스는 API 계층에서만 데이터를 처리하는 역할을 하고, Entity 클래스는 서비스 계층에서만 데이터를 처리하는 역할을 하여 각 클래스 간
역할 분담이 이루어저야 하는데 Entity 객체가 dto 역할까지 담당하여 계층 간 역할 분리가 이루어지지 않았다.

-> 이 문제를 해결하기 위해 dto 클래스와 entity 클래스를 서로 변환해주는 mapper를 만들어 따로 구현한다.

<MapStruct를 이용한 Mapper 자동 생성>
-> MapStruct를 사용하면 dto 클래스와 entity 객체 간 변환 작업을 편리하게 할 수 있다.
-> MapStruct는 매퍼 구현 클래스를 자동으로 생성하는 코드 자동 생성기다.

<DTO 클래스와 엔티티 클래스 분리 이유>
1. 계층별 관심사 분리
2. 코드 구성 단순화
3. REST API 독립성 확보 DTO클래스를 사용하면 원하는 정보만 담아서 제공할 수 있다. 반면 entity클래스에는 해당 객체의 모든 정보가 들어있기 때문에
공개하기를 원하지 않은 정보도 전달된다.

<ExceptionHandler>
-> ExceptionHandler로 예외처리를 할 수 있다.

- 단점
1. 각 Controller클래스에서 @ExceptionHandler를 사용해 RequestBody에 대한 유효성 검증 실패에 대한 에러 처리를 해야 하기 때문에
각 Controller클래스마다 해당 예외처리를 위한 코드가 반복된다.
2. Controller에서 처리해야 하는 예외는 유효성 검증 실패에 대한 예외만 있는 것이 아니기 때문에 하나의 Controller 클래스에 여러 예외에 대한
예외 처리 코드를 작성하게 되므로 @ExceptionHandler를 추가한 에러 처리 핸들러가 코드에 많아지게 된다. -> 코드가 복잡해진다.

<@RestControllerAdvice>
-> RestControllerAdvice는 Controller클래스에서 @ExceptionHandler, @InitBinder, @ModelAttribute가 추가된 메서드를 공유해서 사용한다.
 @RestControllerAdvice를 추가한 클래스를 이용하면 예외처리를 공통화할 수 있다.

<@RestControllerAdvice VS @ControllerAdvice>
@RestControllerAdvice는 @ControllerAdvice의 기능을 포함하고 있고, @ResponseBody의 기능도 포함하고 있다. 따라서
JSON형태의 데이터를 ResponseBody로 전송하기 위해 ResponseEntity로 데이터를 변환할 필요가 없다.
